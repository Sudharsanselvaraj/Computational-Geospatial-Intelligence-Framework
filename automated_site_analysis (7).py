# -*- coding: utf-8 -*-
"""Automated Site Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xlp1ZcjLa-P7JrR8m4SpuBm2bUGOtOVp

# Automated Site Context & Feasibility Analysis  
### Lot-Based Spatial Intelligence System (Hong Kong)

This notebook implements a fully automated spatial analysis workflow for early-stage development feasibility studies.

The system extracts and visualizes:

- Walking accessibility to public transport  
- Driving distance and route efficiency  
- Surrounding land-use context  
- Amenities & competing developments  
- Environmental noise exposure  
- View quality analysis  
- Statutory zoning & lease constraints  

All analysis is dynamically generated from a **Lot ID input**.

# PHASE 1 — Transportation Analysis

This phase evaluates how accessible the site is via:

- Walking routes to MTR / Bus Stops  
- Pedestrian travel time  
- Driving accessibility  
- Ingress / Egress routes  
- 5 / 10 / 15 minute accessibility zones  

Transportation accessibility is a key factor in land valuation and development potential.

## 1. Walking Distance to MTR / Bus Stops

### Purpose

To measure pedestrian accessibility from the site to nearby transport nodes.

### Methodology

- Resolve Lot ID → Coordinates (HK Lands API)
- Extract site footprint from OSM
- Build pedestrian network (OSMnx)
- Snap site centroid to nearest walkable node
- Compute shortest walking routes (NetworkX)
- Estimate travel time (5 km/h standard walking speed)
- Generate 5 / 10 / 15 minute distance rings

### Output

A pedestrian accessibility map displaying:

- Walking routes
- Travel time labels
- Distance rings
- MTR station footprints

Runtime 52sec
"""

# ============================================================
# INSTALLS (RUN ONCE IN COLAB)
# ============================================================
!pip install -q geopandas osmnx contextily shapely pyproj networkx requests matplotlib

# ============================================================
# IMPORTS
# ============================================================
import osmnx as ox
import geopandas as gpd
import contextily as cx
import matplotlib.pyplot as plt
import networkx as nx
import requests
import numpy as np

from shapely.geometry import Point
from pyproj import Transformer

ox.settings.log_console = False
ox.settings.use_cache = True


# ============================================================
# USER INPUT CONFIGURATION
# ============================================================

INPUT_MODE = "MULTIPLE"   # "SINGLE" or "MULTIPLE"

SINGLE_QUERY = {
    "type": "LOT",
    "value": "IL 1657"
}

MULTIPLE_QUERIES = [
    {"type": "LOT", "value": "IL 1657"},
    {"type": "PRN", "value": "12345678"},
    {"type": "STT", "value": "STT1001"}
]

WALK_SPEED_KMPH = 5
MAP_EXTENT = 2000


# ============================================================
# UNIVERSAL SAFE HK LANDSD QUERY RESOLUTION ENGINE
# ============================================================

def resolve_query(data_type, value):

    base_url = "https://mapapi.geodata.gov.hk/gs/api/v1.0.0"
    data_type = data_type.upper().strip()

    try:
        if data_type == "LOT":
            url = f"{base_url}/lus/lot/SearchNumber?text={value.replace(' ','%20')}"
        else:
            url = f"{base_url}/lus/{data_type.lower()}/Search?value={value}"

        response = requests.get(url)

        if response.status_code != 200:
            return None

        data = response.json()

        if "candidates" not in data or len(data["candidates"]) == 0:
            return None

        best = max(data["candidates"], key=lambda x: x.get("score", 0))

        x2326 = best["location"]["x"]
        y2326 = best["location"]["y"]

        lon, lat = Transformer.from_crs(
            2326, 4326, always_xy=True
        ).transform(x2326, y2326)

        return {
            "type": data_type,
            "value": value,
            "longitude": lon,
            "latitude": lat
        }

    except:
        return None


# ============================================================
# EXECUTION LOGIC
# ============================================================

results = []

if INPUT_MODE == "SINGLE":

    result = resolve_query(
        SINGLE_QUERY["type"],
        SINGLE_QUERY["value"]
    )

    if result:
        results.append(result)
    else:
        print(f"{SINGLE_QUERY['type']} {SINGLE_QUERY['value']} → Not Found")

elif INPUT_MODE == "MULTIPLE":

    for query in MULTIPLE_QUERIES:

        result = resolve_query(query["type"], query["value"])

        if result:
            results.append(result)
        else:
            print(f"{query['type']} {query['value']} → Not Found")

else:
    print("INPUT_MODE must be SINGLE or MULTIPLE")


# ============================================================
# WALKING ACCESSIBILITY ANALYSIS
# ============================================================

if len(results) == 0:
    print("No valid locations to analyse.")

for res in results:

    print(f"\nRunning analysis for {res['type']} - {res['value']}")

    lon = res["longitude"]
    lat = res["latitude"]

    # --------------------------------------------------------
    # GET REAL SITE FOOTPRINT
    # --------------------------------------------------------

    osm_site = ox.features_from_point(
        (lat, lon),
        dist=60,
        tags={"building": True}
    ).to_crs(3857)

    if len(osm_site):
        osm_site["area_calc"] = osm_site.geometry.area
        site_geom = osm_site.sort_values(
            "area_calc", ascending=False
        ).geometry.iloc[0]
    else:
        site_geom = gpd.GeoSeries(
            [Point(lon, lat)],
            crs=4326
        ).to_crs(3857).iloc[0].buffer(40)

    site_gdf = gpd.GeoDataFrame(geometry=[site_geom], crs=3857)
    site_point = site_geom.centroid

    # --------------------------------------------------------
    # WALK NETWORK
    # --------------------------------------------------------

    G_walk = ox.graph_from_point(
        (lat, lon),
        dist=3000,
        network_type="walk"
    )

    roads = ox.graph_to_gdfs(
        G_walk,
        nodes=False
    ).to_crs(3857)

    site_centroid_wgs = gpd.GeoSeries(
        [site_point],
        crs=3857
    ).to_crs(4326).iloc[0]

    site_node = ox.distance.nearest_nodes(
        G_walk,
        site_centroid_wgs.x,
        site_centroid_wgs.y
    )

    # --------------------------------------------------------
    # FETCH MTR STATIONS
    # --------------------------------------------------------

    stations = ox.features_from_point(
        (lat, lon),
        tags={"railway": "station"},
        dist=3000
    ).to_crs(3857)

    stations = stations[stations.geometry.notnull()]

    if stations.empty:
        print("No nearby stations found.")
        continue

    stations["station_name"] = stations.apply(
        lambda r: r.get("name:en")
        if isinstance(r.get("name:en"), str)
        else r.get("name")
        if isinstance(r.get("name"), str)
        else "MTR Station",
        axis=1
    )

    stations["dist"] = stations.geometry.centroid.distance(site_point)
    stations = stations.sort_values("dist").head(3)

    # --------------------------------------------------------
    # ROUTE CALCULATION
    # --------------------------------------------------------

    routes = []

    for _, row in stations.iterrows():

        st_centroid = row.geometry.centroid
        st_wgs = gpd.GeoSeries(
            [st_centroid],
            crs=3857
        ).to_crs(4326).iloc[0]

        st_node = ox.distance.nearest_nodes(
            G_walk,
            st_wgs.x,
            st_wgs.y
        )

        try:
            path = nx.shortest_path(
                G_walk,
                site_node,
                st_node,
                weight="length"
            )
        except:
            continue

        route = ox.routing.route_to_gdf(
            G_walk,
            path
        ).to_crs(3857)

        dist_km = round(route.length.sum() / 1000, 2)
        time_min = max(1, round((dist_km / WALK_SPEED_KMPH) * 60))

        routes.append({
            "route": route,
            "distance": dist_km,
            "time": time_min,
            "station_polygon": row.geometry,
            "station_centroid": st_centroid,
            "name": row["station_name"]
        })

    # --------------------------------------------------------
    # PLOT MAP
    # --------------------------------------------------------

    fig, ax = plt.subplots(figsize=(12, 12))

    roads.plot(ax=ax, linewidth=0.25, color="#8a8a8a", alpha=0.4)

    # 15-min shaded area
    gpd.GeoSeries([site_point.buffer(1125)], crs=3857).plot(
        ax=ax, color="#2aa9ff", alpha=0.15
    )

    # Rings
    for d, lbl in [(375, "5 min"), (750, "10 min"), (1125, "15 min")]:
        gpd.GeoSeries([site_point.buffer(d)], crs=3857).boundary.plot(
            ax=ax,
            linestyle=(0, (4, 3)),
            linewidth=2,
            color="#2aa9ff"
        )
        ax.text(site_point.x + d + 120, site_point.y, lbl, fontsize=9)

    colors = ["#4caf50", "#ef5350", "#42a5f5"]

    for i, r in enumerate(routes):

        route_color = colors[i % len(colors)]

        # ROUTE
        r["route"].plot(
            ax=ax,
            linewidth=2.8,
            color=route_color,
            alpha=0.85,
            zorder=5
        )

        # STATION POLYGON (FIXED)
        station_geom = r["station_polygon"]

        if station_geom.geom_type == "Point":
            station_geom = station_geom.buffer(60)

        gpd.GeoSeries([station_geom], crs=3857).plot(
            ax=ax,
            facecolor=route_color,
            edgecolor=route_color,
            linewidth=1,
            alpha=0.25,
            zorder=4
        )

        # TIME LABEL
        mid = r["route"].geometry.iloc[len(r["route"]) // 2].centroid

        ax.text(
            mid.x,
            mid.y,
            f"{r['time']} min\n{r['distance']} km",
            fontsize=9,
            weight="bold",
            color=route_color,
            ha="center",
            zorder=6
        )

        # STATION NAME
        ax.text(
            r["station_centroid"].x,
            r["station_centroid"].y + 120,
            r["name"].upper(),
            fontsize=10,
            weight="bold",
            ha="center",
            zorder=7
        )

    # SITE
    site_gdf.plot(ax=ax, facecolor="red", edgecolor="none")
    ax.text(
        site_point.x,
        site_point.y - 120,
        "SITE",
        color="red",
        weight="bold",
        ha="center"
    )

    ax.set_xlim(site_point.x - MAP_EXTENT, site_point.x + MAP_EXTENT)
    ax.set_ylim(site_point.y - MAP_EXTENT, site_point.y + MAP_EXTENT)

    cx.add_basemap(
        ax,
        source=cx.providers.CartoDB.PositronNoLabels,
        zoom=15,
        alpha=0.4
    )

    ax.set_title(
        f"Walking Accessibility - {res['type']} {res['value']}",
        fontsize=15,
        weight="bold"
    )

    ax.set_axis_off()
    plt.show()

"""## 2. Driving Distance Analysis

### Purpose

To evaluate vehicular accessibility and road connectivity.

### Methodology

- Build OSM drive network
- Assign travel-time weights to roads
- Identify nearest major transport nodes
- Compute shortest travel-time routes
- Generate drive-time buffers (1.5 / 3 / 4.5 mins)
- Visualize ingress (red) & egress (green) routes

### Output

Driving accessibility map including:

- Travel-time rings
- Route arrows
- Station connectivity
- Road hierarchy context

Runtime 49sec
"""

import zipfile

zip_path = "/content/GeoJSON_Statutory_Plans (1).zip"
extract_path = "/content/extracted_data/"

with zipfile.ZipFile(zip_path, 'r') as zip_ref:
    zip_ref.extractall(extract_path)

print("ZIP file extracted successfully.")

# ============================================================
# INSTALLS (Run once)
# ============================================================
!pip install -q geopandas osmnx contextily shapely pyproj networkx requests matplotlib

# ============================================================
# IMPORTS
# ============================================================
import osmnx as ox
import geopandas as gpd
import contextily as cx
import matplotlib.pyplot as plt
import networkx as nx
import requests
import matplotlib.lines as mlines

from shapely.geometry import Point, LineString, MultiLineString
from pyproj import Transformer

ox.settings.use_cache = True
ox.settings.log_console = False


# ============================================================
# USER INPUT CONFIGURATION
# ============================================================

INPUT_MODE = "MULTIPLE"   # "SINGLE" or "MULTIPLE"

SINGLE_QUERY = {
    "type": "LOT",
    "value": "IL 1657"
}

MULTIPLE_QUERIES = [
    {"type": "LOT", "value": "IL 1657"},
    {"type": "PRN", "value": "12345678"},
    {"type": "STT", "value": "STT1001"}
]

DRIVE_SPEED = 35  # km/h
MAP_EXTENT = 1400
OZP_ZONE_PATH = "/content/extracted_data/Statutory Plan GIS Data GeoJSON/ZONE.json"


# ============================================================
# UNIVERSAL SAFE HK LANDSD RESOLVER
# ============================================================

def resolve_query(data_type, value):

    base_url = "https://mapapi.geodata.gov.hk/gs/api/v1.0.0"
    data_type = data_type.upper().strip()

    try:
        if data_type == "LOT":
            url = f"{base_url}/lus/lot/SearchNumber?text={value.replace(' ','%20')}"
        else:
            url = f"{base_url}/lus/{data_type.lower()}/Search?value={value}"

        response = requests.get(url)

        if response.status_code != 200:
            return None

        data = response.json()

        if "candidates" not in data or len(data["candidates"]) == 0:
            return None

        best = max(data["candidates"], key=lambda x: x.get("score", 0))

        x2326 = best["location"]["x"]
        y2326 = best["location"]["y"]

        lon, lat = Transformer.from_crs(
            2326, 4326, always_xy=True
        ).transform(x2326, y2326)

        return {
            "type": data_type,
            "value": value,
            "longitude": lon,
            "latitude": lat
        }

    except:
        return None


# ============================================================
# RESOLVE INPUTS
# ============================================================

results = []

if INPUT_MODE == "SINGLE":
    result = resolve_query(
        SINGLE_QUERY["type"],
        SINGLE_QUERY["value"]
    )
    if result:
        results.append(result)
    else:
        print(f"{SINGLE_QUERY['type']} {SINGLE_QUERY['value']} → Not Found")

elif INPUT_MODE == "MULTIPLE":
    for query in MULTIPLE_QUERIES:
        result = resolve_query(query["type"], query["value"])
        if result:
            results.append(result)
        else:
            print(f"{query['type']} {query['value']} → Not Found")

else:
    print("INPUT_MODE must be SINGLE or MULTIPLE")


# ============================================================
# DRIVING ANALYSIS
# ============================================================

if len(results) == 0:
    print("No valid locations to analyse.")

for res in results:

    print(f"\nRunning driving analysis for {res['type']} - {res['value']}")

    lon = res["longitude"]
    lat = res["latitude"]

    site_point = gpd.GeoSeries(
        [Point(lon, lat)],
        crs=4326
    ).to_crs(3857).iloc[0]

    # --------------------------------------------------------
    # LOAD OZP SITE POLYGON
    # --------------------------------------------------------

    ozp = gpd.read_file(OZP_ZONE_PATH).to_crs(3857)
    site_polygon = ozp[ozp.contains(site_point)].geometry.iloc[0]
    site_gdf = gpd.GeoDataFrame(geometry=[site_polygon], crs=3857)
    centroid = site_polygon.centroid

    # --------------------------------------------------------
    # DRIVE NETWORK
    # --------------------------------------------------------

    G = ox.graph_from_point((lat, lon), dist=3000, network_type="drive")

    for u, v, k, data in G.edges(keys=True, data=True):
        data["travel_time"] = data["length"] / (DRIVE_SPEED * 1000 / 60)

    site_node = ox.distance.nearest_nodes(G, lon, lat)

    # --------------------------------------------------------
    # GET STATIONS
    # --------------------------------------------------------

    stations = ox.features_from_point(
        (lat, lon),
        tags={"railway": "station"},
        dist=3000
    ).to_crs(3857)

    stations["dist"] = stations.centroid.distance(centroid)
    stations = stations.sort_values("dist").head(3)

    # --------------------------------------------------------
    # ROUTE FUNCTION
    # --------------------------------------------------------

    def get_route(node_from, node_to):
        try:
            route = nx.shortest_path(G, node_from, node_to, weight="travel_time")
            return ox.routing.route_to_gdf(G, route).to_crs(3857)
        except:
            return None

    def add_route_arrow(ax, gdf_route, color):
        if gdf_route is None or gdf_route.empty:
            return

        merged = gdf_route.geometry.union_all()

        if isinstance(merged, MultiLineString):
            merged = max(list(merged.geoms), key=lambda g: g.length)

        if not isinstance(merged, LineString):
            return

        coords = list(merged.coords)
        if len(coords) < 2:
            return

        idx = int(len(coords) * 0.6)

        ax.annotate(
            "",
            xy=coords[idx + 1],
            xytext=coords[idx],
            arrowprops=dict(
                arrowstyle="-|>",
                color=color,
                lw=2,
                mutation_scale=18
            ),
            zorder=20
        )

    # --------------------------------------------------------
    # PLOT
    # --------------------------------------------------------

    fig, ax = plt.subplots(figsize=(12,12))
    fig.patch.set_facecolor("#f2f2f2")
    ax.set_facecolor("#f2f2f2")

    cx.add_basemap(
        ax,
        source=cx.providers.CartoDB.PositronNoLabels,
        zoom=17,
        alpha=1.0
    )

    edges = ox.graph_to_gdfs(G, nodes=False).to_crs(3857)
    edges.plot(ax=ax, linewidth=0.6, color="#8f8f8f", alpha=0.35, zorder=1)

    # Distance Rings
    ring1 = centroid.buffer(375)
    ring2 = centroid.buffer(750)
    ring3 = centroid.buffer(1125)

    gpd.GeoSeries([ring3], crs=3857).plot(
        ax=ax,
        color="#f4d03f",
        alpha=0.05,
        zorder=2
)
    gpd.GeoSeries([ring2], crs=3857).plot(
        ax=ax,
        color="#f4d03f",
        alpha=0.07,
        zorder=3
)
    gpd.GeoSeries([ring1], crs=3857).plot(
        ax=ax,
        color="#f4d03f",
        alpha=0.10,
        zorder=4
)



    for ring in [ring3, ring2, ring1]:
        gpd.GeoSeries([ring], crs=3857).boundary.plot(
            ax=ax,
            color="#c8a600",
            linewidth=2,
            linestyle=(0,(6,5)),
            zorder=5
        )

    # Routes + Stations
    for _, station in stations.iterrows():

        st_centroid = station.geometry.centroid
        st_wgs = gpd.GeoSeries([st_centroid], crs=3857).to_crs(4326).iloc[0]
        station_node = ox.distance.nearest_nodes(G, st_wgs.x, st_wgs.y)

        ingress = get_route(station_node, site_node)
        egress  = get_route(site_node, station_node)

        if ingress is not None:
            ingress.plot(ax=ax, linewidth=2.5, color="#e74c3c", zorder=10)
            add_route_arrow(ax, ingress, "#e74c3c")

        if egress is not None:
            egress.plot(ax=ax, linewidth=2.5, color="#27ae60", zorder=10)
            add_route_arrow(ax, egress, "#27ae60")

        # SMART station geometry handling
        station_geom = station.geometry
        if station_geom.geom_type == "Point":
            station_geom = station_geom.buffer(60)

        gpd.GeoSeries([station_geom], crs=3857).plot(
            ax=ax,
            facecolor="#5dade2",
            edgecolor="#2e86c1",
            linewidth=1.5,
            alpha=0.6,
            zorder=7
        )

        name = station.get("name:en") or station.get("name") or "STATION"

        ax.text(
            st_centroid.x,
            st_centroid.y + 120,
            name.upper(),
            fontsize=9,
            weight="bold",
            ha="center",
            bbox=dict(facecolor="white", edgecolor="none", alpha=0.9, pad=2),
            zorder=8
        )

    # Site
    site_gdf.plot(
        ax=ax,
        facecolor="#ff4d4d",
        edgecolor="none",
        alpha=0.45,
        zorder=9
    )

    ax.text(
        centroid.x,
        centroid.y - 70,
        "SITE",
        color="black",
        weight="bold",
        ha="center",
        fontsize=11,
        zorder=10
    )

    ingress_line = mlines.Line2D([], [], color="#e74c3c", linewidth=2.5, label="Ingress Route")
    egress_line  = mlines.Line2D([], [], color="#27ae60", linewidth=2.5, label="Egress Route")

    ax.legend(
        handles=[ingress_line, egress_line],
        loc="lower right",
        frameon=True,
        facecolor="white",
        edgecolor="black"
    )

    ax.set_xlim(centroid.x - MAP_EXTENT, centroid.x + MAP_EXTENT)
    ax.set_ylim(centroid.y - MAP_EXTENT, centroid.y + MAP_EXTENT)

    ax.set_title(
        f"SITE ANALYSIS - Driving Distance ({res['type']} {res['value']})",
        fontsize=16,
        weight="bold"
    )

    ax.set_axis_off()
    plt.tight_layout()
    plt.show()

"""## 3. Transportation Network Analysis

### Purpose

To evaluate multi-modal public transport accessibility and surrounding road connectivity of the site.

### Methodology

- Retrieve OSM transport layers within a 3 km radius  
- Extract major road hierarchy (motorway / trunk / primary / secondary)  
- Identify heavy rail (MTR) corridors  
- Extract existing Light Rail routes  
- Locate railway stations and compute centroids  
- Clip transport layers to focused site extent  
- Apply smart label placement to avoid text overlap  
- Visualize layered transport network with hierarchy styling  

### Output

Transportation accessibility map including:

- MTR heavy rail corridors  
- Existing Light Rail lines  
- Major vehicular circulation network  
- Rail station nodes  
- Site overlay with north orientation  
- Structured legend and contextual basemap  

**Runtime:** ~40 sec

"""

# ============================================================
# INSTALL (Run once)
# ============================================================
!pip install -q geopandas osmnx contextily shapely pyproj requests matplotlib

# ============================================================
# IMPORTS
# ============================================================
import osmnx as ox
import geopandas as gpd
import contextily as cx
import matplotlib.pyplot as plt
import requests
import matplotlib.patches as mpatches
import matplotlib.lines as mlines
import numpy as np

from shapely.geometry import Point, box
from pyproj import Transformer

ox.settings.use_cache = True
ox.settings.log_console = False


# ============================================================
# USER INPUT CONFIGURATION
# ============================================================

INPUT_MODE = "MULTIPLE"   # "SINGLE" or "MULTIPLE"

SINGLE_QUERY = {
    "type": "LOT",
    "value": "IL 1657"
}

MULTIPLE_QUERIES = [
    {"type": "LOT", "value": "IL 1657"},
    {"type": "PRN", "value": "12345678"},
    {"type": "STT", "value": "STT1001"}
]

MAP_RADIUS = 3000

COLOR_EXISTING_RAIL = "#e06a2b"
COLOR_MTR = "#3f78b5"
COLOR_ROADS = "#e85d9e"
COLOR_WATER = "#6fa8dc"
COLOR_BUILDINGS = "#d6d6d6"
COLOR_SITE = "#FF0000"


# ============================================================
# UNIVERSAL SAFE HK LANDSD RESOLVER
# ============================================================

def resolve_query(data_type, value):

    base_url = "https://mapapi.geodata.gov.hk/gs/api/v1.0.0"
    data_type = data_type.upper().strip()

    try:
        if data_type == "LOT":
            url = f"{base_url}/lus/lot/SearchNumber?text={value.replace(' ','%20')}"
        else:
            url = f"{base_url}/lus/{data_type.lower()}/Search?value={value}"

        response = requests.get(url)

        if response.status_code != 200:
            return None

        data = response.json()

        if "candidates" not in data or len(data["candidates"]) == 0:
            return None

        best = max(data["candidates"], key=lambda x: x.get("score", 0))

        x2326 = best["location"]["x"]
        y2326 = best["location"]["y"]

        lon, lat = Transformer.from_crs(
            2326, 4326, always_xy=True
        ).transform(x2326, y2326)

        return {
            "type": data_type,
            "value": value,
            "longitude": lon,
            "latitude": lat
        }

    except:
        return None


# ============================================================
# RESOLVE INPUTS
# ============================================================

results = []

if INPUT_MODE == "SINGLE":

    result = resolve_query(
        SINGLE_QUERY["type"],
        SINGLE_QUERY["value"]
    )

    if result:
        results.append(result)
    else:
        print(f"{SINGLE_QUERY['type']} {SINGLE_QUERY['value']} → Not Found")

elif INPUT_MODE == "MULTIPLE":

    for query in MULTIPLE_QUERIES:

        result = resolve_query(query["type"], query["value"])

        if result:
            results.append(result)
        else:
            print(f"{query['type']} {query['value']} → Not Found")

else:
    print("INPUT_MODE must be SINGLE or MULTIPLE")


# ============================================================
# RUN ANALYSIS FOR EACH VALID INPUT
# ============================================================

if len(results) == 0:
    print("No valid locations to analyse.")


for res in results:

    print(f"\nRunning transport analysis for {res['type']} - {res['value']}")

    lon = res["longitude"]
    lat = res["latitude"]

    site_point = gpd.GeoSeries(
        [Point(lon, lat)],
        crs=4326
    ).to_crs(3857).iloc[0]


    # ============================================================
    # SAFE FETCH FUNCTIONS
    # ============================================================

    def safe_fetch(tags):
        try:
            gdf = ox.features_from_point((lat, lon), dist=MAP_RADIUS, tags=tags)
            if not gdf.empty:
                return gdf.to_crs(3857)
            return gpd.GeoDataFrame(geometry=[], crs=3857)
        except:
            return gpd.GeoDataFrame(geometry=[], crs=3857)

    def keep_lines(gdf):
        if not gdf.empty:
            return gdf[gdf.geometry.type.isin(["LineString","MultiLineString"])]
        return gpd.GeoDataFrame(geometry=[], crs=3857)


    # ============================================================
    # FETCH DATA
    # ============================================================

    buildings = safe_fetch({"building": True})
    roads = keep_lines(safe_fetch({"highway":["motorway","trunk","primary","secondary"]}))
    light_rail = keep_lines(safe_fetch({"railway":"light_rail"}))
    stations = safe_fetch({"railway":"station"})
    water = safe_fetch({"natural":"water"})

    mtr_routes = keep_lines(safe_fetch({
        "railway":["rail","subway"]
    }))


    # ============================================================
    # SITE POLYGON
    # ============================================================

    if not buildings.empty:
        distances = buildings.geometry.distance(site_point)
        nearest_idx = distances.idxmin()
        site_geom = buildings.loc[nearest_idx, "geometry"]
    else:
        site_geom = site_point.buffer(40)

    site_gdf = gpd.GeoDataFrame(geometry=[site_geom], crs=3857)


    # ============================================================
    # PLOT (NO STYLE CHANGE)
    # ============================================================

    fig, ax = plt.subplots(figsize=(18,10))
    fig.patch.set_facecolor("#f4f4f4")
    ax.set_facecolor("#f4f4f4")

    cx.add_basemap(ax, source=cx.providers.CartoDB.Positron, zoom=15, alpha=0.5)

    if not buildings.empty:
        buildings.plot(ax=ax, color=COLOR_BUILDINGS, alpha=0.5, zorder=1)

    if not water.empty:
        water.plot(ax=ax, color=COLOR_WATER, alpha=0.8, zorder=2)

    if not roads.empty:
        roads.plot(ax=ax, color=COLOR_ROADS, linewidth=2.2, zorder=3)


    # ============================================================
    # MTR ROUTES (SAME STYLE)
    # ============================================================

    xmin = site_point.x - 1600
    xmax = site_point.x + 2200
    ymin = site_point.y - 1100
    ymax = site_point.y + 1100

    clip_box = box(xmin, ymin, xmax, ymax)
    clip_gdf = gpd.GeoDataFrame(geometry=[clip_box], crs=3857)

    if not mtr_routes.empty:

        mtr_visible = gpd.clip(mtr_routes, clip_gdf)

        if not mtr_visible.empty:

            mtr_visible.plot(ax=ax, color="white", linewidth=8, zorder=4)
            mtr_visible.plot(ax=ax, color=COLOR_MTR, linewidth=4.5, zorder=5)

            placed_positions = []

            if "name" in mtr_visible.columns:

                unique_names = mtr_visible["name"].dropna().unique()

                for name in unique_names:

                    clean_name = ''.join(c for c in name if ord(c) < 128).strip()
                    if clean_name == "":
                        continue

                    subset = mtr_visible[mtr_visible["name"] == name]
                    merged = subset.union_all()

                    if merged.length < 600:
                        continue

                    midpoint = merged.interpolate(0.5, normalized=True)

                    offset_y = 0

                    for pt in placed_positions:
                        if midpoint.distance(pt) < 500:
                            offset_y += 150

                    new_point = Point(midpoint.x, midpoint.y + offset_y)
                    placed_positions.append(new_point)

                    ax.text(
                        new_point.x,
                        new_point.y,
                        clean_name.upper(),
                        fontsize=9,
                        weight="bold",
                        color=COLOR_MTR,
                        ha="center",
                        va="center",
                        zorder=10,
                        bbox=dict(facecolor="white", edgecolor="none", alpha=0.85, pad=2)
                    )


    # ============================================================
    # LIGHT RAIL
    # ============================================================

    if not light_rail.empty:
        light_rail.plot(ax=ax, color="white", linewidth=6, zorder=4)
        light_rail.plot(ax=ax, color=COLOR_EXISTING_RAIL, linewidth=3.5, zorder=5)


    # ============================================================
    # STATIONS
    # ============================================================

    if not stations.empty:
        station_pts = stations.copy()
        station_pts["geometry"] = station_pts.centroid

        station_pts.plot(
            ax=ax,
            facecolor="white",
            edgecolor=COLOR_EXISTING_RAIL,
            markersize=120,
            linewidth=2,
            zorder=6
        )


    # ============================================================
    # SITE
    # ============================================================

    site_gdf.plot(ax=ax, facecolor=COLOR_SITE, edgecolor="none", zorder=7)

    centroid = site_geom.centroid

    ax.text(centroid.x, centroid.y - 120,
            "SITE",
            fontsize=14,
            weight="bold",
            ha="center")


    # ============================================================
    # NORTH ARROW
    # ============================================================

    nx_pos, ny_pos = 0.07, 0.85

    ax.annotate(
        '',
        xy=(nx_pos, ny_pos),
        xytext=(nx_pos, ny_pos - 0.05),
        xycoords=ax.transAxes,
        arrowprops=dict(facecolor='black',
                        width=1.5,
                        headwidth=8,
                        headlength=10)
    )

    ax.text(nx_pos, ny_pos + 0.01,
            "N",
            transform=ax.transAxes,
            ha='center',
            va='bottom',
            fontsize=12)


    # ============================================================
    # EXTENT
    # ============================================================

    ax.set_xlim(xmin, xmax)
    ax.set_ylim(ymin, ymax)


    # ============================================================
    # LEGEND (UNCHANGED STYLE)
    # ============================================================

    legend_existing_rail = mlines.Line2D([], [], color=COLOR_EXISTING_RAIL,
                                         linewidth=5, label="Existing Light Rail")

    legend_mtr = mlines.Line2D([], [], color=COLOR_MTR,
                               linewidth=5, label="MTR Line")

    legend_roads = mlines.Line2D([], [], color=COLOR_ROADS,
                                 linewidth=5, label="Vehicle Circulation")

    legend_site = mpatches.Patch(facecolor=COLOR_SITE, label="Site")

    legend_station = mlines.Line2D([], [], marker='o', linestyle='None',
                                   markerfacecolor='white',
                                   markeredgecolor=COLOR_EXISTING_RAIL,
                                   markeredgewidth=2,
                                   markersize=9,
                                   label="Rail Station")

    legend = ax.legend(
        handles=[
            legend_existing_rail,
            legend_mtr,
            legend_roads,
            legend_site,
            legend_station
        ],
        loc="lower left",
        bbox_to_anchor=(0.02, 0.15),
        frameon=True,
        facecolor="white",
        edgecolor="black",
        fontsize=10,
        title="Legend"
    )

    legend.get_frame().set_linewidth(2)


    # ============================================================
    # TITLE
    # ============================================================

    ax.set_title(
        f"SITE ANALYSIS – Transportation ({res['type']} {res['value']})",
        fontsize=18,
        weight="bold"
    )

    ax.set_axis_off()
    plt.tight_layout()
    plt.savefig(f"site_analysis_{res['type']}_{res['value']}.png", dpi=300)
    plt.show()

"""# PHASE 2 — Surrounding Amenities & Land Use Context

### Purpose

To understand the immediate urban context around the site.

This analysis extracts:

- Residential zones
- Commercial / Industrial areas
- Schools & institutions
- Public parks
- Transport nodes
- Bus stop clustering

### Intelligent Logic

The system adjusts label priorities depending on zoning:

- Residential → Schools, Parks
- Commercial → Restaurants, Banks
- Institutional → Hospitals, Colleges

### Output

Consultant-style land use context map with categorized legend.

Runtime 1min
"""

# ============================================================
# INSTALLS (RUN ONCE)
# ============================================================
!pip install -q geopandas osmnx contextily shapely pyproj requests networkx matplotlib scikit-learn

# ============================================================
# IMPORTS
# ============================================================
import osmnx as ox
import geopandas as gpd
import matplotlib.pyplot as plt
import contextily as cx
import requests
import networkx as nx
import matplotlib.patches as mpatches
import numpy as np
import textwrap

from shapely.geometry import Point
from pyproj import Transformer
from sklearn.cluster import KMeans

ox.settings.use_cache = True
ox.settings.log_console = False


# ============================================================
# USER INPUT CONFIGURATION
# ============================================================

INPUT_MODE = "SINGLE"   # "SINGLE" or "MULTIPLE"

SINGLE_QUERY = {
    "type": "LOT",
    "value": "IL 1657"
}

MULTIPLE_QUERIES = [
    {"type": "LOT", "value": "IL 1657"},
    {"type": "LOT", "value": "IL 904"}
]

FETCH_RADIUS = 1500
MAP_HALF_SIZE = 900
OZP_ZONE_PATH = "/content/extracted_data/Statutory Plan GIS Data GeoJSON/ZONE.json"

MTR_COLOR = "#ffd166"


# ============================================================
# UNIVERSAL HK RESOLVER
# ============================================================

def resolve_query(data_type, value):

    base_url = "https://mapapi.geodata.gov.hk/gs/api/v1.0.0"
    data_type = data_type.upper().strip()

    try:
        if data_type == "LOT":
            url = f"{base_url}/lus/lot/SearchNumber?text={value.replace(' ','%20')}"
        else:
            url = f"{base_url}/lus/{data_type.lower()}/Search?value={value}"

        r = requests.get(url)
        if r.status_code != 200:
            return None

        data = r.json()
        if "candidates" not in data or len(data["candidates"]) == 0:
            return None

        best = max(data["candidates"], key=lambda x: x["score"])

        x2326 = best["location"]["x"]
        y2326 = best["location"]["y"]

        lon, lat = Transformer.from_crs(
            2326, 4326, always_xy=True
        ).transform(x2326, y2326)

        return lon, lat

    except:
        return None


# ============================================================
# TEXT HELPERS
# ============================================================

def wrap_label(text, width=18):
    return "\n".join(textwrap.wrap(str(text), width))

def get_constraint_text(row):
    for k in ["DESC_ENG", "NOTE_ENG", "REMARKS", "CONSTRAINT", "ANNOTATION"]:
        if k in row and isinstance(row[k], str) and row[k].strip():
            return row[k]
    return "No special statutory planning constraints identified."

def infer_site_type(zone):
    if zone.startswith("R"): return "RESIDENTIAL"
    if zone.startswith("C"): return "COMMERCIAL"
    if zone.startswith("G"): return "INSTITUTIONAL"
    if "HOTEL" in zone.upper() or zone.startswith("OU"): return "HOTEL"
    return "MIXED"

def context_rules(site_type):
    if site_type == "RESIDENTIAL":
        return {"amenity":["school","college","university"],"leisure":["park"],"place":["neighbourhood"]}
    if site_type == "COMMERCIAL":
        return {"amenity":["bank","restaurant","market"],"railway":["station"]}
    if site_type == "INSTITUTIONAL":
        return {"amenity":["school","college","hospital"],"leisure":["park"]}
    return {"amenity":True,"leisure":True}


# ============================================================
# RESOLVE INPUTS
# ============================================================

locations = []

if INPUT_MODE == "SINGLE":
    coords = resolve_query(SINGLE_QUERY["type"], SINGLE_QUERY["value"])
    if coords:
        locations.append((SINGLE_QUERY["value"], coords))

elif INPUT_MODE == "MULTIPLE":
    for q in MULTIPLE_QUERIES:
        coords = resolve_query(q["type"], q["value"])
        if coords:
            locations.append((q["value"], coords))

if len(locations) == 0:
    print("No valid inputs found.")


# ============================================================
# LOAD OZP DATA ONCE
# ============================================================

ozp = gpd.read_file(OZP_ZONE_PATH).to_crs(3857)


# ============================================================
# MAIN LOOP
# ============================================================

for LOT_ID, coords in locations:

    print(f"Running analysis for {LOT_ID}")

    lon, lat = coords
    site_point = gpd.GeoSeries([Point(lon, lat)], crs=4326).to_crs(3857).iloc[0]

    # --------------------------------------------------------
    # ZONING
    # --------------------------------------------------------

    primary = ozp[ozp.contains(site_point)]

    if primary.empty:
        print("No zoning polygon found.")
        continue

    primary = primary.iloc[0]
    zone = primary["ZONE_LABEL"]
    SITE_TYPE = infer_site_type(zone)
    LABEL_RULES = context_rules(SITE_TYPE)

    # --------------------------------------------------------
    # FETCH OSM DATA
    # --------------------------------------------------------

    polygons = ox.features_from_point(
        (lat, lon),
        dist=FETCH_RADIUS,
        tags={"landuse":True,"leisure":True,"amenity":True,"building":True}
    ).to_crs(3857)

    residential = polygons[polygons.get("landuse")=="residential"]
    industrial  = polygons[polygons.get("landuse").isin(["industrial","commercial"])]
    parks       = polygons[polygons.get("leisure")=="park"]
    schools     = polygons[polygons.get("amenity").isin(["school","college","university"])]
    buildings   = polygons[polygons.get("building").notnull()]

    # --------------------------------------------------------
    # SITE FOOTPRINT
    # --------------------------------------------------------

    candidates = polygons[
        polygons.geometry.geom_type.isin(["Polygon","MultiPolygon"]) &
        (polygons.geometry.distance(site_point) < 40)
    ]

    site_geom = (
        candidates.assign(area=candidates.area)
        .sort_values("area", ascending=False)
        .geometry.iloc[0]
        if len(candidates) else site_point.buffer(40)
    )

    site_gdf = gpd.GeoDataFrame(geometry=[site_geom], crs=3857)

    # --------------------------------------------------------
    # MTR STATIONS
    # --------------------------------------------------------

    stations = ox.features_from_point(
        (lat, lon), tags={"railway":"station"}, dist=2000
    ).to_crs(3857)

    if not stations.empty:
        stations["name"] = stations.get("name:en").fillna(stations.get("name"))
        stations["centroid"] = stations.geometry.centroid
        stations["dist"] = stations["centroid"].distance(site_point)
        stations = stations.dropna(subset=["name"]).sort_values("dist").head(2)

    # --------------------------------------------------------
    # BUS STOPS (CLUSTERED)
    # --------------------------------------------------------

    bus_stops = ox.features_from_point(
        (lat, lon), tags={"highway":"bus_stop"}, dist=900
    ).to_crs(3857)

    if len(bus_stops) > 6:
        coords_array = np.array([[g.x,g.y] for g in bus_stops.geometry])
        bus_stops["cluster"] = KMeans(n_clusters=6, random_state=0).fit(coords_array).labels_
        bus_stops = bus_stops.groupby("cluster").first()

    # --------------------------------------------------------
    # WALK ROUTES TO MTR
    # --------------------------------------------------------

    routes = []

    if not stations.empty:
        G = ox.graph_from_point((lat, lon), dist=2000, network_type="walk")
        site_node = ox.distance.nearest_nodes(G, lon, lat)

        for _, st in stations.iterrows():
            ll = gpd.GeoSeries([st.centroid], crs=3857).to_crs(4326).iloc[0]
            st_node = ox.distance.nearest_nodes(G, ll.x, ll.y)
            path = nx.shortest_path(G, site_node, st_node, weight="length")
            routes.append(ox.routing.route_to_gdf(G, path).to_crs(3857))

    # --------------------------------------------------------
    # PLACE LABELS
    # --------------------------------------------------------

    labels = ox.features_from_point(
        (lat, lon), dist=800, tags=LABEL_RULES
    ).to_crs(3857)

    labels["label"] = labels.get("name:en").fillna(labels.get("name"))
    labels = labels.dropna(subset=["label"]).drop_duplicates("label").head(24)

# ============================================================
# PLOT
# ============================================================
fig, ax = plt.subplots(figsize=(12,12))

cx.add_basemap(ax, source=cx.providers.CartoDB.Positron, zoom=16, alpha=0.95)

ax.set_xlim(site_point.x-MAP_HALF_SIZE, site_point.x+MAP_HALF_SIZE)
ax.set_ylim(site_point.y-MAP_HALF_SIZE, site_point.y+MAP_HALF_SIZE)
ax.set_aspect("equal")
ax.autoscale(False)

residential.plot(ax=ax,color="#f2c6a0",alpha=0.75)
industrial.plot(ax=ax,color="#b39ddb",alpha=0.75)
parks.plot(ax=ax,color="#b7dfb9",alpha=0.9)
schools.plot(ax=ax,color="#9ecae1",alpha=0.9)
buildings.plot(ax=ax,color="#d9d9d9",alpha=0.35)

for r in routes:
    r.plot(ax=ax,color="#005eff",linewidth=2.2,linestyle="--")

bus_stops.plot(ax=ax,color="#0d47a1",markersize=35,zorder=9)

# MTR FOOTPRINTS (ORANGE)
stations.plot(
    ax=ax,
    facecolor=MTR_COLOR,
    edgecolor="none",
    linewidth=0,
    alpha=0.9,
    zorder=10
)


site_gdf.plot(ax=ax,facecolor="#e53935",edgecolor="darkred",linewidth=2,zorder=11)
ax.text(site_geom.centroid.x, site_geom.centroid.y,"SITE",
        color="white",weight="bold",ha="center",va="center",zorder=12)

# MTR NAMES (SAME STYLE AS OTHER LABELS)
for _, st in stations.iterrows():
    ax.text(
        st.centroid.x,
        st.centroid.y + 120,
        wrap_label(st["name"], 18),
        fontsize=9,
        ha="center",
        va="center",
        bbox=dict(facecolor="white", edgecolor="none", alpha=0.8, pad=1.0),
        zorder=12,
        clip_on=True
    )

# ============================================================
# DRAW PLACE LABELS
# ============================================================

offsets = [(0,35),(0,-35),(35,0),(-35,0),(25,25),(-25,25)]
placed = []

for i, (_, row) in enumerate(labels.iterrows()):
    p = row.geometry.representative_point()

    if p.distance(site_point) < 140:
        continue

    if any(p.distance(pp) < 120 for pp in placed):
        continue

    dx, dy = offsets[i % len(offsets)]

    ax.text(
        p.x + dx,
        p.y + dy,
        wrap_label(row["label"], 18),
        fontsize=9,
        ha="center",
        va="center",
        bbox=dict(
            facecolor="white",
            edgecolor="none",
            alpha=0.85,
            boxstyle="round,pad=0.25"
        ),
        zorder=12,
        clip_on=True
    )

    placed.append(p)

# INFO BOX
ax.text(
    0.015,0.985,
    f"Lot: {LOT_ID}\n"
    f"OZP Plan: {primary['PLAN_NO']}\n"
    f"Zoning: {zone}\n"
    f"Site Type: {SITE_TYPE}\n",
    transform=ax.transAxes,
    ha="left",va="top",fontsize=9.2,
    bbox=dict(facecolor="white",edgecolor="black",pad=6)
)

# LEGEND
ax.legend(
    handles=[
        mpatches.Patch(color="#f2c6a0",label="Residential"),
        mpatches.Patch(color="#b39ddb",label="Industrial / Commercial"),
        mpatches.Patch(color="#b7dfb9",label="Public Park"),
        mpatches.Patch(color="#9ecae1",label="School / Institution"),
        mpatches.Patch(color=MTR_COLOR,label="MTR Station"),
        mpatches.Patch(color="#e53935",label="Site"),
        mpatches.Patch(color="#005eff",label="Pedestrian Route to MTR"),
        mpatches.Patch(color="#0d47a1",label="Bus Stop"),
    ],
    loc="lower left",
    bbox_to_anchor=(0.02,0.08),
    fontsize=8.5,
    framealpha=0.95
)

ax.set_title("Automated Site Context Analysis (Building-Type Driven)",fontsize=15,weight="bold")
ax.set_axis_off()

plt.savefig("SITE_CONTEXT_FINAL_BUILDING_LOGIC_COMPLETE.pdf",dpi=400)
plt.show()

"""# PHASE 3 — Competing Developments Analysis
### Purpose

To assess surrounding development intensity and potential competition.

### Methodology

- Load LandsD Building Height Dataset
- Compute building height (TopHeight – BaseHeight)
- Convert height → storeys
- Sector-based clustering (30° radial sectors)
- Label tallest building per direction

### Classification

- ≥120m → City View Impact
- ≥60m → Open View Impact
- <60m → Green / Low-rise context

### Output

Directional storey labeling & competitive intensity visualization.

"""

import zipfile
import os

ZIP_NAME = "/content/Building_GEOJSON (1).zip"
EXTRACT_DIR = "building_data"

os.makedirs(EXTRACT_DIR, exist_ok=True)

with zipfile.ZipFile(ZIP_NAME, 'r') as zip_ref:
    zip_ref.extractall(EXTRACT_DIR)

print("Extracted files:")
for root, dirs, files in os.walk(EXTRACT_DIR):
    for f in files:
        print(os.path.join(root, f))

# ============================================================
# INSTALLS
# ============================================================
!pip install -q geopandas osmnx shapely pyproj requests matplotlib pandas

# ============================================================
# IMPORTS
# ============================================================
import osmnx as ox
import geopandas as gpd
import matplotlib.pyplot as plt
import numpy as np
import requests
import pandas as pd
import math

from shapely.geometry import Point, Polygon
from pyproj import Transformer
from matplotlib.patches import Wedge, Patch

ox.settings.use_cache = True
ox.settings.log_console = False

# ============================================================
# INPUT CONFIGURATION SYSTEM
# ============================================================

INPUT_MODE = "SINGLE"   # "SINGLE" or "MULTIPLE"

SINGLE_QUERY = {
    "type": "LOT",
    "value": "IL 1657"
}

MULTIPLE_QUERIES = [
    {"type": "LOT", "value": "IL 1657"},
    {"type": "LOT", "value": "IL 904"},
]

# ============================================================
# ANALYSIS PARAMETERS
# ============================================================

FETCH_RADIUS = 1500
MAP_RADIUS = 800
VIEW_RADIUS = 360
ARC_WIDTH = 40
SECTOR_SIZE = 20

LANDSD_FILE = "/content/building_data/Building_Outline_Public_v20260119_Building_converted.geojson"

# ============================================================
# QUERY RESOLUTION
# ============================================================

def resolve_lot(lot):
    url = f"https://mapapi.geodata.gov.hk/gs/api/v1.0.0/lus/lot/SearchNumber?text={lot.replace(' ','%20')}"
    r = requests.get(url)
    best = max(r.json()["candidates"], key=lambda x: x["score"])
    return best["location"]["x"], best["location"]["y"]

def resolve_query(query):
    if query["type"] == "LOT":
        x2326, y2326 = resolve_lot(query["value"])
        lon, lat = Transformer.from_crs(2326, 4326, always_xy=True).transform(x2326, y2326)
        return lon, lat, query["value"]
    else:
        raise ValueError("Unsupported query type")

if INPUT_MODE == "SINGLE":
    ACTIVE_QUERIES = [SINGLE_QUERY]
elif INPUT_MODE == "MULTIPLE":
    ACTIVE_QUERIES = MULTIPLE_QUERIES
else:
    raise ValueError("INPUT_MODE must be SINGLE or MULTIPLE")

# ============================================================
# LOAD HEIGHT DATA ONCE
# ============================================================

landsd = gpd.read_file(LANDSD_FILE).to_crs(3857)
landsd["HEIGHT_M"] = landsd["TopHeight"] - landsd["BaseHeight"]
landsd = landsd[landsd["HEIGHT_M"] > 5]

# ============================================================
# MAIN LOOP
# ============================================================

for query in ACTIVE_QUERIES:

    lon, lat, LOT_ID = resolve_query(query)
    print(f"Processing {LOT_ID}...")

    # --------------------------------------------------------
    # SITE POLYGON
    # --------------------------------------------------------
    site_building = ox.features_from_point(
        (lat, lon),
        dist=60,
        tags={"building": True}
    ).to_crs(3857)

    if len(site_building):
        site_geom = (
            site_building.assign(area=site_building.area)
            .sort_values("area", ascending=False)
            .geometry.iloc[0]
        )
    else:
        site_geom = gpd.GeoSeries([Point(lon, lat)], crs=4326).to_crs(3857).iloc[0].buffer(25)

    center = site_geom.centroid
    analysis_circle = center.buffer(MAP_RADIUS)

    # --------------------------------------------------------
    # CONTEXT DATA
    # --------------------------------------------------------
    def fetch_layer(tags):
        gdf = ox.features_from_point((lat, lon), dist=FETCH_RADIUS, tags=tags).to_crs(3857)
        return gdf[gdf.intersects(analysis_circle)]

    buildings = fetch_layer({"building": True})
    parks = fetch_layer({"leisure":"park","landuse":"grass","natural":"wood"})
    water = fetch_layer({"waterway":True,"natural":"water"})

    nearby = landsd[landsd.intersects(analysis_circle)].copy()

    # --------------------------------------------------------
    # CREATE FIGURE
    # --------------------------------------------------------
    fig, ax = plt.subplots(figsize=(12,12))
    ax.set_facecolor("#f2f2f2")
    ax.set_xlim(center.x - MAP_RADIUS, center.x + MAP_RADIUS)
    ax.set_ylim(center.y - MAP_RADIUS, center.y + MAP_RADIUS)
    ax.set_aspect("equal")

    # --------------------------------------------------------
    # BASE MAP
    # --------------------------------------------------------
    if len(parks):
        parks.plot(ax=ax, color="#b8c8a0", edgecolor="none", zorder=1)

    if len(water):
        water.plot(ax=ax, color="#6bb6d9", edgecolor="none", zorder=2)

    buildings.plot(ax=ax, color="#e3e3e3", edgecolor="none", zorder=3)

    # --------------------------------------------------------
    # RADIAL GUIDES
    # --------------------------------------------------------
    for angle in range(0, 360, SECTOR_SIZE):
        rad = np.radians(angle)
        ax.plot(
            [center.x, center.x + MAP_RADIUS*np.cos(rad)],
            [center.y, center.y + MAP_RADIUS*np.sin(rad)],
            linestyle=(0,(2,4)),
            linewidth=0.8,
            color="#d49a2a",
            alpha=0.35,
            zorder=4
        )

    # --------------------------------------------------------
    # MPD RINGS
    # --------------------------------------------------------
    for d in [80,160,200]:
        circle = center.buffer(d)
        gpd.GeoSeries([circle], crs=3857).boundary.plot(
            ax=ax,
            linestyle=(0,(4,4)),
            linewidth=1.2,
            color="#555555",
            alpha=0.9,
            zorder=5
        )

        ax.text(
            center.x + d,
            center.y,
            f"{d} mPD",
            fontsize=8,
            weight="bold",
            color="white",
            bbox=dict(facecolor="black", edgecolor="none", pad=2),
            zorder=6
        )

    # --------------------------------------------------------
    # SECTOR FUNCTION
    # --------------------------------------------------------
    def create_sector(center, radius, start_angle, end_angle):
        angles = np.linspace(start_angle, end_angle, 40)
        points = [(center.x, center.y)]
        for angle in angles:
            rad = np.radians(angle)
            x = center.x + radius * np.cos(rad)
            y = center.y + radius * np.sin(rad)
            points.append((x, y))
        return Polygon(points)

    # --------------------------------------------------------
    # METRIC COLLECTION
    # --------------------------------------------------------
    sector_data = []

    for angle in range(0, 360, SECTOR_SIZE):
        start = angle
        end = angle + SECTOR_SIZE
        sector = create_sector(center, VIEW_RADIUS, start, end)
        sector_area = sector.area

        green_area = parks.intersection(sector).area.sum() if len(parks) else 0
        water_area = water.intersection(sector).area.sum() if len(water) else 0
        building_area = buildings.intersection(sector).area.sum() if len(buildings) else 0

        sector_heights = nearby[nearby.intersects(sector)]
        avg_height = sector_heights["HEIGHT_M"].mean() if len(sector_heights) else 0

        sector_data.append({
            "start": start,
            "end": end,
            "green": green_area / sector_area if sector_area else 0,
            "water": water_area / sector_area if sector_area else 0,
            "building": building_area / sector_area if sector_area else 0,
            "avg_height": avg_height
        })

    df = pd.DataFrame(sector_data)

    # --------------------------------------------------------
    # NORMALIZATION
    # --------------------------------------------------------
    def normalize(series):
        if series.max() - series.min() == 0:
            return series * 0
        return (series - series.min()) / (series.max() - series.min())

    df["green_n"] = normalize(df["green"])
    df["water_n"] = normalize(df["water"])
    df["height_n"] = normalize(df["avg_height"])
    df["density_n"] = normalize(df["building"])

    # --------------------------------------------------------
    # SCORING
    # --------------------------------------------------------
    df["city_score"] = df["height_n"] * df["density_n"]
    df["green_score"] = df["green_n"]
    df["water_score"] = df["water_n"]
    df["open_score"] = (1 - df["density_n"]) * (1 - df["height_n"])

    df["view"] = df[["green_score","water_score","city_score","open_score"]].idxmax(axis=1)
    df["view"] = df["view"].str.replace("_score","").str.upper()

    # --------------------------------------------------------
    # MERGE SECTORS
    # --------------------------------------------------------
    merged = []
    current_start = df.iloc[0]["start"]
    current_end = df.iloc[0]["end"]
    current_type = df.iloc[0]["view"]

    for i in range(1, len(df)):
        row = df.iloc[i]
        if row["view"] == current_type:
            current_end = row["end"]
        else:
            merged.append((current_start, current_end, current_type))
            current_start = row["start"]
            current_end = row["end"]
            current_type = row["view"]

    merged.append((current_start, current_end, current_type))

    if merged[0][2] == merged[-1][2]:
        merged[0] = (merged[-1][0], merged[0][1], merged[0][2])
        merged.pop()

    # --------------------------------------------------------
    # DRAW VIEW ARCS + LABELS
    # --------------------------------------------------------
    color_map = {
        "GREEN": "#3dbb74",
        "WATER": "#4fa3d1",
        "CITY": "#e75b8c",
        "OPEN": "#f0a25a"
    }

    for start, end, view_type in merged:

        arc = Wedge(
            (center.x, center.y),
            VIEW_RADIUS,
            start,
            end,
            width=ARC_WIDTH,
            facecolor=color_map[view_type],
            edgecolor="white",
            linewidth=2,
            zorder=7
        )
        ax.add_patch(arc)

        mid_angle = (start + end) / 2
        rad = np.radians(mid_angle)
        label_radius = VIEW_RADIUS - ARC_WIDTH/2

        lx = center.x + label_radius * np.cos(rad)
        ly = center.y + label_radius * np.sin(rad)

        rotation = mid_angle - 90
        if 90 < mid_angle < 270:
            rotation += 180

        if (end - start) >= SECTOR_SIZE:
            ax.text(
                lx,
                ly,
                f"{view_type} VIEW",
                fontsize=10,
                weight="bold",
                color="white",
                ha="center",
                va="center",
                rotation=rotation,
                rotation_mode="anchor",
                zorder=8
            )

    # --------------------------------------------------------
    # HEIGHT LABELS
    # --------------------------------------------------------
    top_buildings = nearby.sort_values("HEIGHT_M", ascending=False).head(25)

    for _, row in top_buildings.iterrows():
        centroid = row.geometry.centroid
        ax.text(
            centroid.x,
            centroid.y,
            f"{row['HEIGHT_M']:.1f} m",
            fontsize=7,
            color="white",
            bbox=dict(facecolor="black", edgecolor="none", pad=1.5),
            zorder=12
        )

    # --------------------------------------------------------
    # SITE
    # --------------------------------------------------------
    gpd.GeoSeries([site_geom]).plot(
        ax=ax,
        facecolor="#e74c3c",
        edgecolor="white",
        linewidth=1.5,
        zorder=13
    )

    ax.text(
        center.x,
        center.y - 35,
        "SITE",
        fontsize=12,
        weight="bold",
        ha="center",
        va="top",
        zorder=14
    )

    # --------------------------------------------------------
    # LEGEND
    # --------------------------------------------------------
    legend_elements = [
        Patch(facecolor="#3dbb74", label="Green View"),
        Patch(facecolor="#4fa3d1", label="Water View"),
        Patch(facecolor="#e75b8c", label="City View"),
        Patch(facecolor="#f0a25a", label="Open View"),
    ]

    ax.legend(
        handles=legend_elements,
        loc="lower right",
        frameon=True,
        facecolor="white",
        edgecolor="#444444",
        framealpha=0.95,
        fontsize=9
    )

    # --------------------------------------------------------
    # FINAL OUTPUT
    # --------------------------------------------------------
    ax.set_title(f"SITE ANALYSIS – View Analysis ({LOT_ID})", fontsize=16, weight="bold")
    ax.set_axis_off()

    plt.tight_layout()
    plt.savefig(f"VIEW_ANALYSIS_{LOT_ID.replace(' ','_')}.pdf", dpi=400)
    plt.show()
    plt.close(fig)

"""# PHASE 4 — Road Traffic Noise Impact

### Purpose

To estimate environmental noise exposure from nearby roads.

This is critical for:

- Residential developments
- Hotel projects
- Mixed-use feasibility

### Methodology

- Extract road network (OSM)
- Classify road hierarchy
- Assign traffic intensity weights
- Rasterize road network
- Apply exponential distance decay model
- Apply Gaussian smoothing
- Generate heatmap

### Output

Noise intensity heatmap with:

- High / Moderate / Low noise zones
- Distance rings
- Site overlay

"""

# ============================================================
# PROFESSIONAL ENVIRONMENTAL NOISE MODEL
# Traffic Flow | Façade Exposure | Barriers | Reflection
# Terrain | 150m Study | Optimized
# MULTI-INPUT READY VERSION
# ============================================================

!pip install -q osmnx geopandas contextily pyproj shapely numpy pandas matplotlib requests

import osmnx as ox
import geopandas as gpd
import contextily as cx
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import requests

from shapely.geometry import Point, LineString
from shapely.ops import unary_union
from pyproj import Transformer

# ------------------------------------------------------------
# INPUT CONFIGURATION SYSTEM
# ------------------------------------------------------------

INPUT_MODE = "SINGLE"   # "SINGLE" or "MULTIPLE"

SINGLE_QUERY = {
    "type": "LOT",
    "value": "IL 1657"
}

MULTIPLE_QUERIES = [
    {"type": "LOT", "value": "IL 1657"},
    {"type": "LOT", "value": "IL 904"},
]

# ------------------------------------------------------------
# SETTINGS
# ------------------------------------------------------------

STUDY_RADIUS = 150
GRID_RES = 6
ZOOM = 19

TRAFFIC_FLOW = 1200
HEAVY_PERCENT = 0.12
SPEED = 40

BARRIER_HEIGHT = 3
GROUND_ABSORPTION = 0.6

ox.settings.use_cache = True
ox.settings.log_console = False

# ------------------------------------------------------------
# QUERY RESOLUTION
# ------------------------------------------------------------

def resolve_lot(lot):
    url = (
        "https://mapapi.geodata.gov.hk/gs/api/v1.0.0/"
        "lus/lot/SearchNumber"
        f"?text={lot.replace(' ', '%20')}"
    )
    r = requests.get(url)
    r.raise_for_status()
    best = max(r.json()["candidates"], key=lambda x: x["score"])
    return best["location"]["x"], best["location"]["y"]

def resolve_query(query):
    if query["type"] == "LOT":
        x2326, y2326 = resolve_lot(query["value"])
        lon, lat = Transformer.from_crs(2326, 4326, always_xy=True).transform(x2326, y2326)
        return lon, lat, query["value"]
    else:
        raise ValueError("Unsupported query type")

if INPUT_MODE == "SINGLE":
    ACTIVE_QUERIES = [SINGLE_QUERY]
elif INPUT_MODE == "MULTIPLE":
    ACTIVE_QUERIES = MULTIPLE_QUERIES
else:
    raise ValueError("INPUT_MODE must be SINGLE or MULTIPLE")

# ============================================================
# MAIN LOOP
# ============================================================

for query in ACTIVE_QUERIES:

    lon, lat, LOT_ID = resolve_query(query)
    print(f"Processing {LOT_ID}...")

    site_point = gpd.GeoSeries([Point(lon, lat)], crs=4326).to_crs(3857).iloc[0]

    # --------------------------------------------------------
    # SITE POLYGON
    # --------------------------------------------------------

    site_candidates = ox.features_from_point(
        (lat, lon),
        dist=60,
        tags={"building": True}
    ).to_crs(3857)

    site_candidates["area"] = site_candidates.area
    site_polygon = site_candidates.sort_values("area", ascending=False).geometry.iloc[0]
    site_gdf = gpd.GeoDataFrame(geometry=[site_polygon], crs=3857)

    # --------------------------------------------------------
    # ROADS
    # --------------------------------------------------------

    roads = ox.features_from_point(
        (lat, lon),
        dist=STUDY_RADIUS,
        tags={"highway": True}
    ).to_crs(3857)

    roads = roads[roads.geometry.type.isin(["LineString","MultiLineString"])]

    # --------------------------------------------------------
    # TRAFFIC EMISSION MODEL
    # --------------------------------------------------------

    def traffic_emission(flow, heavy_pct, speed):

        L_light = 27.7 + 10*np.log10(flow*(1-heavy_pct)) + 0.02*speed
        L_heavy = 23.1 + 10*np.log10(flow*heavy_pct) + 0.08*speed

        energy = 10**(L_light/10) + 10**(L_heavy/10)
        return 10*np.log10(energy)

    L_source = traffic_emission(TRAFFIC_FLOW, HEAVY_PERCENT, SPEED)

    # --------------------------------------------------------
    # GRID
    # --------------------------------------------------------

    minx, miny, maxx, maxy = site_polygon.buffer(STUDY_RADIUS).bounds

    x_vals = np.arange(minx, maxx, GRID_RES)
    y_vals = np.arange(miny, maxy, GRID_RES)

    X, Y = np.meshgrid(x_vals, y_vals)
    noise_energy = np.zeros_like(X)

    # --------------------------------------------------------
    # PROPAGATION MODEL
    # --------------------------------------------------------

    for geom in roads.geometry:

        if geom.geom_type == "MultiLineString":
            lines = geom.geoms
        else:
            lines = [geom]

        for line in lines:

            d = np.vectorize(lambda xx, yy: line.distance(Point(xx, yy)))(X, Y)

            A_div = 20*np.log10(d + 1)
            A_ground = GROUND_ABSORPTION * 5*np.log10(d + 1)

            A_barrier = np.where(
                np.vectorize(lambda xx, yy:
                    site_polygon.buffer(5).intersects(
                        LineString([(line.centroid.x, line.centroid.y),(xx,yy)])
                    )
                )(X,Y),
                8, 0
            )

            A_reflect = -2

            L = L_source - A_div - A_ground - A_barrier + A_reflect
            noise_energy += 10**(L/10)

    noise = 10*np.log10(noise_energy + 1e-9)

    # --------------------------------------------------------
    # BUILDING FAÇADE EXPOSURE
    # --------------------------------------------------------

    buildings = ox.features_from_point(
        (lat, lon),
        dist=STUDY_RADIUS,
        tags={"building": True}
    ).to_crs(3857)

    buildings = buildings[buildings.geometry.type.isin(["Polygon","MultiPolygon"])]

    facade_levels = []

    for geom in buildings.geometry:
        centroid = geom.centroid
        val = np.mean(noise[
            (np.abs(X-centroid.x)<GRID_RES) &
            (np.abs(Y-centroid.y)<GRID_RES)
        ])
        facade_levels.append(val)

    buildings["facade_db"] = facade_levels

    # --------------------------------------------------------
    # PLOT
    # --------------------------------------------------------

    fig, ax = plt.subplots(figsize=(10,10))

    center = site_polygon.centroid
    ax.set_xlim(center.x - STUDY_RADIUS, center.x + STUDY_RADIUS)
    ax.set_ylim(center.y - STUDY_RADIUS, center.y + STUDY_RADIUS)

    cx.add_basemap(
        ax,
        source=cx.providers.Esri.WorldImagery,
        crs=3857,
        zoom=ZOOM,
        alpha=1
    )

    levels = np.arange(45, 105, 5)

    cont = ax.contourf(
        X, Y, noise,
        levels=levels,
        cmap="RdYlGn_r",
        alpha=0.45
    )

    ax.contour(
        X, Y, noise,
        levels=levels,
        colors="black",
        linewidths=0.4,
        alpha=0.3
    )

    buildings.plot(
        ax=ax,
        column="facade_db",
        cmap="RdYlGn_r",
        linewidth=0.2,
        edgecolor="black",
        alpha=0.9
    )

    site_gdf.plot(
        ax=ax,
        facecolor="red",
        edgecolor="none",
        linewidth=2,
        zorder=10
    )

    site_centroid = site_polygon.centroid

    ax.text(
        site_centroid.x,
        site_centroid.y,
        "SITE",
        fontsize=14,
        weight="bold",
        color="white",
        ha="center",
        va="center",
        zorder=20
    )

    cbar = plt.colorbar(cont, ax=ax, fraction=0.03, pad=0.02)
    cbar.set_label("Noise Level Leq dB(A)")

    ax.set_title(
        f"Near-Site Environmental Noise Assessment\n{LOT_ID}\n"
        "Traffic + Barrier + Reflection + Ground Effects",
        fontsize=14, weight="bold"
    )

    ax.set_axis_off()
    plt.tight_layout()
    plt.savefig(f"NOISE_MODEL_{LOT_ID.replace(' ','_')}.pdf", dpi=400)
    plt.show()
    plt.close(fig)

"""**End of Notebook**"""